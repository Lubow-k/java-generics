
# Javac Generics Overview

As opposed to the _C++ compiler_, which generates a class/method for each template parameter, the _Java compiler_ deals with generics in a different way with type erasure, bridge methods and extra casts. This makes objects with generic type in Java are non-[reifiable][3] types.

# Implementation

The work to analyse the tree and generate class files is performed by a series of _visitors_ that process the entries on the compiler's To Do list.

* Attr
* Flow
* TransTypes
* Lower
* Gen

Code involving generic types is translated to code without generic types, using  `TransTypes`.  So, the source codes about generics are  [TransTypes.java][1]  and  [Types.java][2].

As stated above `TransTypes` inherits `TreeTranslator` and indirectly `JCTree.Visitor`. Therefore, this class defines many [translation functions][10] into code without generics for each kind of AST.


## Erasure of Generic Types

During the type erasure process, the compiler erases all type parameters and replaces each with

* its **first bound** if the type parameter is _bounded_
```java  
public class Box<T extends Comparable<T>> {  
	private T data;
}  
```  

```java  
public class Box {  
	private Comparable data;
}  
```  

* **Object** if the type parameter is _unbounded_

```java  
public class Box<T> {  
	private T data;
}  
```  

```java  
public class Box {  
	private Object data;
}  
```  

Every type has an upper bound, but not every type has a lower one. Usually it is set to _bottom type_. If _wildcard_ is used, bounds can be defined by the user.

So, type erasure is possible and implemented like [visitor class in Types.java][11] for mapping types to erased ones.

[Java Specification: Type Erasure][4]

## Bridge Methods
Javac sometimes creates a synthetic methods, which is called a bridge methods, as part of the [type erasure process for classes][12].

For example, let's look at 2 classes:

```java  
public class Box<T> {  
	public T data; 
	public Box(T data) { this.data = data; } 
	public void set(T data) { this.data = data; }
}  
  
public class SmallBox extends Box<Integer> {  
	public SmallBox(Integer data) { super(data); } 
	public void set(Integer data) { super.set(data); }
}  
```  

After type erasure:

```java  
public class Box {  
	public Object data; 
	public Box(Object data) { this.data = data; } 
	public void set(Object data) { this.data = data; }
 }  
  
public class SmallBox extends Box {  
	public SmallBox(Integer data) { super(data); } 
	public void set(Integer data) { super.set(data); }
 }  
```  

At this stage the compiler checks whether the [bridge method is needed][8].

In our case, `SmallBox.set(Integer)` method does not override the `Box.set(Object)` method! That's why javac [generates the bridge][9] in a `SmallBox` class:


```java  
public class SmallBox extends Box {  
	public SmallBox(Integer data) { super(data); } 
	public void set(Integer data) { super.set(data); }    
	
	// Synthetic (generated by the compiler)  
	public void set(Object data) { 
		set((Integer) data); 
	}
}  
```  


**Pay attention!**

You cannot overload a method where the formal parameter types of each overload erase to the same raw type.
```java  
public class Example {  
	public void print(Set<String> strSet) { } 
	public void print(Set<Integer> intSet) { }
}  
```  
Neither within one class nor in the derived.
```java  
Box<T> someMethod(Consumer<Box<? extends T>> action) { }  
  
// in other class/interface  
// consider SmallBox covariant return type  
@Override SmallBox<T, U> someMethod(Consumer<SmallBox<? extends T, U>> action) { }  
```  

The compiler has a check for this, so you will get the following error:

> have the same erasure, yet neither overrides the other

For the same reason, no need to create bridge methods manually; same compilation error will happen :)

## Type Casts

Also after erasing types there are situations that do not require additional bridge methods, but require [type casting][6].

```java  
class Box<T> { T data; }   

Box<Integer> box; 
Integer x = box.data;   
```  

After type erasure:

```java  
class Box { Object data; }   

Box box; 
Integer x = box.data;  // Object  
```  

So, add cast:
```java  
Integer x = (Integer) box.data;  // Integer  
```  

Of course, not in all cases a type cast is needed (e.g., if the erased type is a subtype of expression's type). There is an additional [—Åheck for this][7].


# Related to Generics
#### but weakly related to type erasure in javac)


## Type Wildcards

Wildcards are type arguments in the form `<?>`, optionally with an upper or lower bound:
* upper bound - `extends`

  We cannot pass anything in `List<? extends Number>` except `null`. Reading an element from the list will return a `Number`.

* lower bound - `super`

  Reading from a list defined as `List<? super Number>` returns elements of type `Object`. Adding to such a list requires either elements of type `Number`,  any subtype of `Number` or `null`.

* unbounded type `List<?>` means `List<? extends Object>`

**PECS** - Producer Extends Consumer Super


## Raw Types

Raw types are closely related to wildcards. Raw types can be thought of as wildcards whose type rules are deliberately unsound, to accommodate interaction with _legacy code_.

```java
class Box<T> { 
	T data; 
	class InnerBox { }
}   
```

If the actual type argument is omitted, a raw type of `Box<T>` is created:

```java
Box box;              // warning: Box is a raw type
Box.InnerBox inner;   // warning: Box.InnerBox is a raw type
```


Although using raw types is the same as storing each value as  `Object`, there is a big difference between the raw type and the parameterized type with `<Object> ` as type parameter:


```java
List a = new ArrayList<String>();   // warning, but no compilation error
a.add("Hello");
a.add(Boolean.FALSE);               // not a compilation error!
                                    // unsafe code to runtime

List<String> b = new ArrayList<String>();  
List<Object> c = b;                 // compilation error, generics are invariant
```

As a consequence, you lose type safety if you use raw type like  `List`, but not if you use a parameterized type like  `List<Object>`. The same situation with raw `List` and `List<(?)>`. You can't add just any arbitrary object to a `List<(?)>`. On the other hand, you can add just about anything to a `List`.


**Pay attention!**  
The use  of raw types in code written after the introduction of generics into the Java programming language is strongly discouraged. Also the use it often leads to _heap pollution_.

```java
// heap pollition with raw types
List s = new ArrayList<Integer>();
List<String> ss = s;                   // warning
s.add(1);                              // warning
Iterator<String> iter = ss.iterator();

while (iter.hasNext()) {
	String str = iter.next();      // ClassCastException
}
```

## Diamond Operator

Thanks to **type inference**, Java SE 7 and above allows to replace a pair of angle brackets containing one or more type parameters with simply an empty pair of angle brackets (_diamond operator_ < >).
```java  
Box<String> box = new Box<String>("A");  
```  
```java  
Box<String> box = new Box<>("A"); 
``` 

## Restrictions on Generics

-   Cannot instantiate generic types with primitive types;
-   Cannot create instances of type parameters;
-   Cannot declare static fields whose types are type parameters;
-   Cannot use casts or  _instanceof_  with parameterized types;
-   Cannot create arrays of parameterized types;
-   Cannot create, catch, or throw objects of parameterized types;
-   Cannot overload a method where the formal parameter types of each overload erase to the same raw type.

[Description and examples.][5]



# Java Generics vs C++ Templates


**C++ Templates:**
* Implementation: _monomorphization_. Templates allow for complete _code specialization_ at compile-time, resulting in highly optimized code for specific data types.
* Powerful metaprogramming: enabling _code generation at compile time_.
* Compilation errors: terrible! The situation has improved quite a lot with use of _requires_ and _C++20 concepts_.
* Use of primitive type arguments: _allowed_.
* Type safety: _supported_.


**Java Generics:**
* Implementation: _type erasure_. Type information is removed at runtime. This can lead to performance limitations and _issues with reflection_.
* No compile-time specialization: generics _don't allow for code specialization_ at compile time, leading to less optimized code for specific data types.
* Use of primitive type arguments: _not allowed without boxing_ .
* Requirements: via _inheritance_.
* Type safety: _supported_. Generics enforce type constraints at compile-time, preventing type errors.


To understand why Java chose this way, let's look at history. What was there before Java 5?
> Java has no templates or other implementation of parameterized types. There is a set of collections: Vector, Stack, and Hashtable that hold Object references, and through which you can satisfy your collection needs, but these collections are not designed for efficiency like the C++ STL.

Now it is clear why they chose to erase types into Objects and support raw types rather than allow separate specializations that would interfere with _backwards compatibility_.

[More details about the choice of erasing types.][13]



[1]: https://github.com/openjdk/jdk/blob/master/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TransTypes.java "Bridges creation"
[2]:https://github.com/openjdk/jdk/blob/master/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Types.java "Type erasure"
[3]:https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.7 "Reifiable types"
[4]:https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.6 "Type erasure specification"
[5]:https://docs.oracle.com/javase/tutorial/java/generics/restrictions.html "Restrictions"


[6]:https://github.com/openjdk/jdk/blob/367e0a65561f95aad61b40930d5f46843fee3444/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TransTypes.java#L169-L181
[7]:https://github.com/openjdk/jdk/blob/367e0a65561f95aad61b40930d5f46843fee3444/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TransTypes.java#L134-L142
[8]:https://github.com/openjdk/jdk/blob/367e0a65561f95aad61b40930d5f46843fee3444/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TransTypes.java#L364-L366
[9]:https://github.com/openjdk/jdk/blob/367e0a65561f95aad61b40930d5f46843fee3444/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TransTypes.java#L236-L240
[10]:https://github.com/openjdk/jdk/blob/367e0a65561f95aad61b40930d5f46843fee3444/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TransTypes.java#L436-L438
[11]:https://github.com/openjdk/jdk/blob/367e0a65561f95aad61b40930d5f46843fee3444/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Types.java#L2409
[12]:https://github.com/openjdk/jdk/blob/367e0a65561f95aad61b40930d5f46843fee3444/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TransTypes.java#L1215

[13]:https://openjdk.org/projects/valhalla/design-notes/in-defense-of-erasure
